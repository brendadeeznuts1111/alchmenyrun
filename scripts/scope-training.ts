#!/usr/bin/env bun
/**
 * Scope System Training Guide
 * Interactive training for team adoption
 * Usage: bun run scripts/scope-training.ts
 *
 * CODEOWNERS TEST: This file should trigger @alice.smith and @infra_dev1 for review
 */

import { ApplicationScope } from "../src/scope";

class ScopeTrainingGuide {
  private currentStep = 0;
  private app: ApplicationScope | null = null;

  async startTraining(): Promise<void> {
    console.log("üéì Welcome to Alchemy Scope System Training!");
    console.log("This interactive guide will teach you how to use scopes effectively.");
    console.log("=" .repeat(80));
    console.log("");

    const steps = [
      { name: "Introduction to Scopes", method: this.stepIntroduction },
      { name: "Creating Your First Scope", method: this.stepCreateScope },
      { name: "Understanding Scope Hierarchy", method: this.stepHierarchy },
      { name: "Resource Management", method: this.stepResources },
      { name: "Nested Scopes", method: this.stepNestedScopes },
      { name: "Finalization & Cleanup", method: this.stepFinalization },
      { name: "CLI Tools", method: this.stepCLI },
      { name: "Best Practices", method: this.stepBestPractices },
      { name: "Troubleshooting", method: this.stepTroubleshooting },
      { name: "Advanced Features", method: this.stepAdvanced }
    ];

    for (let i = 0; i < steps.length; i++) {
      this.currentStep = i + 1;
      console.log(`\nüìö Step ${this.currentStep}/${steps.length}: ${steps[i].name}`);
      console.log("-".repeat(60));

      try {
        await steps[i].method.call(this);
        console.log(`‚úÖ Step ${this.currentStep} completed successfully!`);

        if (i < steps.length - 1) {
          await this.waitForContinue();
        }
      } catch (error) {
        console.error(`‚ùå Step ${this.currentStep} failed:`, error);
        break;
      }
    }

    console.log("\nüéâ Training completed! You now know how to use the Alchemy Scope System.");
    console.log("üìñ For more details, see: docs/guides/alchemy-scopes.md");

    // Cleanup
    await this.cleanup();
  }

  private async stepIntroduction(): Promise<void> {
    console.log(`
üîç What are Scopes?

Scopes are Alchemy's hierarchical containers that provide:

1. **Naming Isolation** - Every resource gets a unique path
2. **State Isolation** - Each scope owns its own state file
3. **Cleanup Isolation** - Destroy scopes without affecting siblings

Think of scopes like directories in a filesystem:
- Application scope = root directory (e.g., "my-app/")
- Stage scope = environment (e.g., "my-app/prod/")
- Nested scope = service layer (e.g., "my-app/prod/backend/")
- Resource scope = individual resources (e.g., "my-app/prod/backend/api-worker")

Benefits:
‚úÖ Zero cross-environment interference
‚úÖ Reliable resource cleanup
‚úÖ Cost-effective CI/CD pipelines
‚úÖ Enterprise-grade lifecycle management
    `);
  }

  private async stepCreateScope(): Promise<void> {
    console.log(`
üèóÔ∏è Creating Your First Scope

Let's create a scope for training purposes:
    `);

    this.app = new ApplicationScope({
      name: "training-app",
      stage: "demo",
      stateDir: ".alchemy-training",
      destroyStrategy: "sequential"
    });

    await this.app.initialize();

    console.log("‚úÖ Created training scope: training-app/demo");
    console.log("üìÅ State directory: .alchemy-training/training-app/demo/");

    // Show current state
    const stats = await this.app.getStats();
    console.log(`üìä Current stats: ${stats.totalResources} resources, ${stats.nestedScopes} nested scopes`);
  }

  private async stepHierarchy(): Promise<void> {
    console.log(`
üè¢ Understanding Scope Hierarchy

Scope paths follow this pattern:
[application]/[stage]/[nested]/[resource]

Examples:
‚Ä¢ training-app/demo (application + stage)
‚Ä¢ training-app/demo/backend (with nested scope)
‚Ä¢ training-app/demo/backend/api-worker (with resource)

Each level provides isolation:
- **Application**: Project-wide container
- **Stage**: Environment isolation (dev/staging/prod/pr-*)
- **Nested**: Service/component grouping
- **Resource**: Individual cloud resources
    `);

    if (this.app) {
      console.log(`Your current scope path: ${this.app.scopePath}`);
      console.log(`Application: ${this.app.name}`);
      console.log(`Stage: ${this.app.stage}`);
    }
  }

  private async stepResources(): Promise<void> {
    console.log(`
üì¶ Resource Management

Scopes automatically track all resources created within them.
Let's add some test resources:
    `);

    if (!this.app) throw new Error("App not initialized");

    // Add some example resources
    await this.app.addResource("demo-worker", {
      id: "demo-worker-1",
      type: "worker",
      name: "demo-api-worker",
      createdAt: Date.now(),
      updatedAt: Date.now(),
      url: "https://demo-worker.alchemy.run"
    });

    await this.app.addResource("demo-database", {
      id: "demo-db-1",
      type: "d1",
      name: "demo-database",
      createdAt: Date.now(),
      updatedAt: Date.now(),
      size: "100MB"
    });

    const resources = await this.app.getResources();
    console.log(`‚úÖ Added ${Object.keys(resources).length} resources:`);

    for (const [id, resource] of Object.entries(resources)) {
      console.log(`   ‚Ä¢ ${resource.type}: ${resource.name} (${id})`);
    }

    console.log(`
üí° Key Points:
‚Ä¢ Resources are automatically tracked
‚Ä¢ Each resource gets a unique ID within the scope
‚Ä¢ State persists across deployments
‚Ä¢ Resources can be inspected and managed via CLI
    `);
  }

  private async stepNestedScopes(): Promise<void> {
    console.log(`
üèóÔ∏è Nested Scopes

Nested scopes help organize related resources by service layer.
Let's create nested scopes for different parts of our application:
    `);

    if (!this.app) throw new Error("App not initialized");

    // Register nested scopes
    await this.app.registerNestedScope("backend");
    await this.app.registerNestedScope("frontend");
    await this.app.registerNestedScope("monitoring");

    const nestedScopes = await this.app.getNestedScopes();
    console.log(`‚úÖ Created ${nestedScopes.length} nested scopes: ${nestedScopes.join(", ")}`);

    console.log(`
üí° When to use nested scopes:
‚Ä¢ Backend services (API, workers, databases)
‚Ä¢ Frontend services (CDN, static hosting)
‚Ä¢ Monitoring & logging infrastructure
‚Ä¢ Third-party integrations
‚Ä¢ Team-specific resources

Benefits:
‚Ä¢ Logical grouping of related resources
‚Ä¢ Independent cleanup of service layers
‚Ä¢ Better organization for large applications
‚Ä¢ Easier debugging and maintenance
    `);
  }

  private async stepFinalization(): Promise<void> {
    console.log(`
üßπ Finalization & Cleanup

Finalization compares your current code with scope state and cleans up orphaned resources.

Let's see how it works:
    `);

    if (!this.app) throw new Error("App not initialized");

    // First, show dry-run
    console.log("üîç Running dry-run finalization (safe preview):");
    const dryRunReport = await this.app.finalize({
      dryRun: true,
      strategy: "conservative"
    });

    console.log(`   Would delete: ${dryRunReport.resourcesDeleted} resources`);
    console.log(`   Would process: ${dryRunReport.nestedScopesProcessed} nested scopes`);
    console.log(`   Duration: ${dryRunReport.duration}ms`);

    if (dryRunReport.resourcesDeleted > 0) {
      console.log(`
üí° Dry-run shows what WOULD be cleaned up.
In a real scenario, this would remove resources no longer defined in your code.
      `);
    }

    console.log(`
üéØ Finalization Strategies:

‚Ä¢ **Conservative** (default): Stops on first error, safest for production
‚Ä¢ **Aggressive**: Continues despite errors, faster for CI/CD cleanup

üîß When Finalization Runs:
‚Ä¢ Manual: await app.finalize()
‚Ä¢ Automatic: End of nested scope blocks
‚Ä¢ CLI: alchemy finalize --stage <stage>
‚Ä¢ CI/CD: Automatic cleanup workflows
    `);
  }

  private async stepCLI(): Promise<void> {
    console.log(`
üíª CLI Tools

The scope system comes with powerful CLI tools for inspection and management:
    `);

    const commands = [
      { cmd: "bun run scope:list", desc: "List all scopes in your project" },
      { cmd: "bun run scope:inspect training-app demo", desc: "Detailed scope information" },
      { cmd: "bun run scope:stats", desc: "Scope system statistics" },
      { cmd: "bun run src/commands/finalize.ts --app training-app --stage demo --dry-run", desc: "Preview cleanup" }
    ];

    for (const { cmd, desc } of commands) {
      console.log(`   ${cmd}`);
      console.log(`   ‚îî‚îÄ ${desc}`);
      console.log("");
    }

    console.log(`
üìä Try these commands after training:

1. List all scopes:
   bun run scope:list

2. Inspect your training scope:
   bun run scope:inspect training-app demo

3. Check system stats:
   bun run scope:stats

4. Preview cleanup:
   bun run src/commands/finalize.ts --app training-app --stage demo --dry-run
    `);
  }

  private async stepBestPractices(): Promise<void> {
    console.log(`
‚ú® Best Practices

üéØ Scope Naming:
‚Ä¢ Use kebab-case: my-app, user-service, api-gateway
‚Ä¢ Stage names: dev, staging, prod, pr-123
‚Ä¢ Nested scopes: backend, frontend, monitoring, integrations

üèóÔ∏è Scope Organization:
‚Ä¢ One application scope per project
‚Ä¢ Use stage names that match your environments
‚Ä¢ Group related resources in nested scopes
‚Ä¢ Keep scope hierarchies shallow (max 3-4 levels)

üîí Security:
‚Ä¢ Use profiles for credential isolation
‚Ä¢ Never commit scope state files (.alchemy/)
‚Ä¢ Rotate API tokens regularly
‚Ä¢ Audit scope access patterns

üßπ Cleanup:
‚Ä¢ Run finalization regularly in CI/CD
‚Ä¢ Use dry-run mode for safety
‚Ä¢ Monitor for orphaned resources
‚Ä¢ Set up automated cleanup workflows

üìà Scaling:
‚Ä¢ Use parallel finalization for CI speed
‚Ä¢ Enable state file versioning for critical apps
‚Ä¢ Monitor scope system health
‚Ä¢ Archive old scope state files
    `);
  }

  private async stepTroubleshooting(): Promise<void> {
    console.log(`
üîß Troubleshooting Common Issues

‚ùå "State file locked by another process"
üí° Solution: Wait for other deployments to complete, or use emergency unlock
   bun run alchemy finalize --force --stage <stuck-stage>

‚ùå "Resource not found in scope"
üí° Solution: Check if resource was created in the correct scope
   bun run scope:inspect <app> <stage>

‚ùå "Too many resources in scope"
üí° Solution: Use nested scopes for better organization
   await alchemy.run("service-name", async () => { ... });

‚ùå "Finalization taking too long"
üí° Solution: Use parallel strategy for CI/CD
   await app.finalize({ strategy: "parallel" });

‚ùå "State file corrupted"
üí° Solution: Restore from backup (if versioning enabled)
   Or recreate scope: rm -rf .alchemy/<app>/<stage>/state.json

üîç Debugging Commands:
‚Ä¢ bun run scope:state <app> <stage>          # Raw state file
‚Ä¢ bun run scope:monitor --once               # Health check
‚Ä¢ bun run scope:list --json                  # Machine-readable output

üìû Getting Help:
‚Ä¢ Check docs/guides/alchemy-scopes.md
‚Ä¢ Run CLI commands with --help
‚Ä¢ Check .alchemy/ directory structure
    `);
  }

  private async stepAdvanced(): Promise<void> {
    console.log(`
üöÄ Advanced Features

üîÑ State Backends:
‚Ä¢ File system (default): Simple, local storage
‚Ä¢ R2: Cloud storage for distributed teams
‚Ä¢ S3: AWS integration for enterprise
‚Ä¢ Composite: File + cloud for reliability

üîí Distributed Locking:
‚Ä¢ File-based locks (default)
‚Ä¢ Cloud-based locks for distributed teams
‚Ä¢ Composite locking for high availability

üì¶ Versioning & Backups:
‚Ä¢ Automatic state file backups
‚Ä¢ Point-in-time recovery
‚Ä¢ Configurable retention policies
‚Ä¢ Emergency rollback capabilities

üìä Monitoring & Alerting:
‚Ä¢ Real-time health monitoring
‚Ä¢ Automated alerts via Telegram/webhooks
‚Ä¢ Performance metrics and trends
‚Ä¢ Anomaly detection

üîß Enterprise Features:
‚Ä¢ Audit trails for all scope operations
‚Ä¢ Multi-tenant scope isolation
‚Ä¢ Compliance reporting
‚Ä¢ Automated governance checks

üí° Advanced Configuration:

\`\`\`typescript
const app = new ApplicationScope({
  name: "enterprise-app",
  stage: "prod",
  destroyStrategy: "parallel",

  // Advanced state management
  stateDir: ".alchemy",
  enableLocking: true,

  // Versioning and backups
  enableVersioning: true,
  maxBackupVersions: 30,

  // Cloud storage
  backend: "composite", // file + r2
  r2Bucket: r2Bucket // Your R2 bucket
});
\`\`\`
    `);
  }

  private async waitForContinue(): Promise<void> {
    console.log("\n‚è≥ Press Enter to continue to the next step...");

    return new Promise((resolve) => {
      process.stdin.once("data", () => {
        resolve();
      });
    });
  }

  private async cleanup(): Promise<void> {
    console.log("\nüßπ Cleaning up training resources...");

    if (this.app) {
      try {
        await this.app.finalize({ force: true });
      } catch (error) {
        console.warn("Training cleanup failed:", error);
      }
    }

    // Remove training state directory
    try {
      const fs = require("fs");
      if (fs.existsSync(".alchemy-training")) {
        fs.rmSync(".alchemy-training", { recursive: true, force: true });
      }
    } catch (error) {
      console.warn("Failed to remove training directory:", error);
    }
  }
}

async function main() {
  const guide = new ScopeTrainingGuide();
  await guide.startTraining();
}

if (import.meta.main) {
  main().catch(error => {
    console.error("Training failed:", error);
    process.exit(1);
  });
}
