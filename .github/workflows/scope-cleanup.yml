name: ðŸ”§ Scope Cleanup
# CODEOWNERS TEST: This file should trigger @alice.smith, @infra_dev1, and @diana.prince for review

on:
  # Manual trigger for administrators
  workflow_dispatch:
    inputs:
      stage:
        description: "Stage to cleanup (leave empty for all PR stages)"
        required: false
        default: ""
      strategy:
        description: "Cleanup strategy"
        required: false
        default: "conservative"
        type: choice
        options:
          - conservative
          - aggressive
      dry_run:
        description: "Dry run mode"
        required: false
        default: true
        type: boolean

  # Automatic cleanup on PR close
  pull_request:
    types: [closed]

  # Scheduled cleanup (daily at 2 AM UTC)
  schedule:
    - cron: "0 2 * * *"

  # Allow manual cleanup via repository dispatch
  repository_dispatch:
    types: [scope-cleanup]

jobs:
  cleanup:
    name: ðŸ§¹ Scope Cleanup
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: ðŸ“¦ Install dependencies
        run: bun install

      - name: ðŸ” Detect cleanup targets
        id: detect
        run: |
          # Determine what to clean up based on trigger type
          case "${{ github.event_name }}" in
            "pull_request")
              if [ "${{ github.event.pull_request.merged }}" = "false" ]; then
                echo "Skipping cleanup - PR was closed without merging"
                echo "skip=true" >> $GITHUB_OUTPUT
                exit 0
              fi
              STAGE="pr-${{ github.event.pull_request.number }}"
              echo "stage=$STAGE" >> $GITHUB_OUTPUT
              echo "reason=PR closed" >> $GITHUB_OUTPUT
              ;;
            "schedule")
              # Daily cleanup - target all PR stages older than 7 days
              echo "stage=all-pr" >> $GITHUB_OUTPUT
              echo "reason=scheduled cleanup" >> $GITHUB_OUTPUT
              ;;
            "workflow_dispatch")
              STAGE="${{ inputs.stage }}"
              if [ -z "$STAGE" ]; then
                STAGE="all-pr"
              fi
              echo "stage=$STAGE" >> $GITHUB_OUTPUT
              echo "reason=manual trigger" >> $GITHUB_OUTPUT
              ;;
            "repository_dispatch")
              STAGE="${{ github.event.client_payload.stage }}"
              echo "stage=${STAGE:-all-pr}" >> $GITHUB_OUTPUT
              echo "reason=repository dispatch" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "stage=all-pr" >> $GITHUB_OUTPUT
              echo "reason=default" >> $GITHUB_OUTPUT
              ;;
          esac

          # Set strategy
          STRATEGY="${{ github.event.inputs.strategy || 'conservative' }}"
          echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT

          # Set dry run
          DRY_RUN="${{ github.event.inputs.dry_run != 'false' && 'true' || 'false' }}"
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT

      - name: ðŸ”’ Wait for concurrent jobs
        if: steps.detect.outputs.skip != 'true'
        run: |
          # Prevent multiple cleanup jobs from running simultaneously
          # This prevents race conditions when multiple PRs close at once
          echo "Waiting for other cleanup jobs to complete..."
          # Implementation would use a lock mechanism here

      - name: ðŸ“‹ Preview cleanup (dry run)
        if: steps.detect.outputs.skip != 'true' && steps.detect.outputs.dry_run == 'true'
        run: |
          echo "ðŸ” Running cleanup in DRY RUN mode"
          echo "Stage: ${{ steps.detect.outputs.stage }}"
          echo "Strategy: ${{ steps.detect.outputs.strategy }}"
          echo "Reason: ${{ steps.detect.outputs.reason }}"
          echo ""

          # Run finalize command in dry-run mode
          if [ "${{ steps.detect.outputs.stage }}" = "all-pr" ]; then
            bun run alchemy finalize --all --dry-run --strategy ${{ steps.detect.outputs.strategy }}
          else
            bun run alchemy finalize --stage ${{ steps.detect.outputs.stage }} --dry-run --strategy ${{ steps.detect.outputs.strategy }}
          fi

      - name: ðŸ§¹ Execute cleanup
        if: steps.detect.outputs.skip != 'true' && steps.detect.outputs.dry_run == 'false'
        env:
          # Set environment variables for Cloudflare access
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          ALCHEMY_PROFILE: ci
        run: |
          echo "ðŸ§¹ Executing scope cleanup"
          echo "Stage: ${{ steps.detect.outputs.stage }}"
          echo "Strategy: ${{ steps.detect.outputs.strategy }}"
          echo "Reason: ${{ steps.detect.outputs.reason }}"
          echo ""

          # Run finalize command
          if [ "${{ steps.detect.outputs.stage }}" = "all-pr" ]; then
            bun run alchemy finalize --all --strategy ${{ steps.detect.outputs.strategy }} --force
          else
            bun run alchemy finalize --stage ${{ steps.detect.outputs.stage }} --strategy ${{ steps.detect.outputs.strategy }} --force
          fi

      - name: ðŸ“Š Generate cleanup report
        if: steps.detect.outputs.skip != 'true'
        run: |
          echo "## ðŸ§¹ Scope Cleanup Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | ${{ steps.detect.outputs.reason }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | ${{ steps.detect.outputs.stage }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Strategy | ${{ steps.detect.outputs.strategy }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dry Run | ${{ steps.detect.outputs.dry_run }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Timestamp | $(date -u +'%Y-%m-%d %H:%M:%S UTC') |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.detect.outputs.dry_run }}" = "false" ]; then
            echo "### ðŸ“‹ Cleanup Results" >> $GITHUB_STEP_SUMMARY
            echo "âœ… Scope cleanup completed successfully" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the job logs above for detailed cleanup statistics." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ðŸ‘ï¸  Dry Run Results" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ” Preview of what would be cleaned up" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Review the dry run output above to ensure the cleanup is safe." >> $GITHUB_STEP_SUMMARY
          fi

      - name: ðŸ“¢ Notify on failure
        if: failure() && steps.detect.outputs.skip != 'true'
        run: |
          echo "âŒ Scope cleanup failed"
          echo "Check the workflow logs for details"

          # Could add Slack/Discord notification here
          # Example: send notification to cleanup-alerts channel

      - name: âœ… Success notification
        if: success() && steps.detect.outputs.skip != 'true' && steps.detect.outputs.dry_run == 'false'
        run: |
          echo "âœ… Scope cleanup completed successfully"
          echo "Stage: ${{ steps.detect.outputs.stage }}"
          echo "Strategy: ${{ steps.detect.outputs.strategy }}"

          # Could add success notification here

  # Optional: Health check job
  health-check:
    name: ðŸ¥ Health Check
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: ðŸ“¦ Install dependencies
        run: bun install

      - name: ðŸ¥ Run scope health check
        run: |
          echo "ðŸ¥ Running scope system health check..."

          # Check for orphaned state files
          if [ -d ".alchemy" ]; then
            echo "ðŸ“Š Analyzing state files..."

            # Count state files
            STATE_COUNT=$(find .alchemy -name "state.json" 2>/dev/null | wc -l)
            echo "Found $STATE_COUNT state files"

            # Check for locked files
            LOCK_COUNT=$(find .alchemy -name ".lock" 2>/dev/null | wc -l)
            echo "Found $LOCK_COUNT locked scopes"

            if [ "$LOCK_COUNT" -gt 0 ]; then
              echo "âš ï¸  Found locked scopes - may indicate stuck processes"
              find .alchemy -name ".lock" -exec ls -la {} \;
            fi
          else
            echo "â„¹ï¸  No .alchemy directory found"
          fi

          echo "âœ… Health check completed"

      - name: ðŸ“Š Report health metrics
        run: |
          echo "## ðŸ¥ Scope Health Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Health check completed" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ” Analyzed scope state files" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“Š Generated cleanup metrics" >> $GITHUB_STEP_SUMMARY
