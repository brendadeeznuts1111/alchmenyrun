import type { worker } from "../alchemy.run.ts";

export default {
  async fetch(request: Request, env: typeof worker.Env) {
    const url = new URL(request.url);
    const path = url.pathname;

    // Route based on path
    if (path === "/dynamic") {
      return handleDynamicWorker(request, env);
    } else if (path === "/metrics") {
      return handleMetricsWorker(request, env);
    } else if (path === "/config") {
      return handleConfigWorker(request, env);
    } else {
      return handleHome(request, env);
    }
  },
};

async function handleDynamicWorker(request: Request, env: typeof worker.Env) {
  const dynamicWorker = env.LOADER.get(
    `dynamic-${Math.random()}`,
    async () => {
      return {
        compatibilityDate: "2025-06-01",
        mainModule: "index.js",
        modules: {
          "index.js": `
            export default {
              async fetch(request) {
                return new Response('Hello! This response was generated by a dynamically loaded worker.');
              }
            }
          `,
        },
      };
    },
  );

  const entrypoint = dynamicWorker.getEntrypoint();
  return entrypoint.fetch(new URL(request.url));
}

async function handleMetricsWorker(request: Request, env: typeof worker.Env) {
  const metricsWorker = env.LOADER.get(
    "metrics-collector",
    async () => {
      return {
        compatibilityDate: "2025-06-01",
        mainModule: "metrics.js",
        modules: {
          "metrics.js": `
            export default {
              async fetch(request) {
                const metrics = {
                  timestamp: new Date().toISOString(),
                  activeConnections: Math.floor(Math.random() * 100),
                  responseTime: Math.floor(Math.random() * 50) + 'ms',
                  healthScore: (Math.random() * 0.1 + 0.9).toFixed(3),
                };
                
                return new Response(JSON.stringify(metrics, null, 2), {
                  headers: { 'Content-Type': 'application/json' }
                });
              }
            }
          `,
        },
      };
    },
  );

  const entrypoint = metricsWorker.getEntrypoint();
  return entrypoint.fetch(new URL(request.url));
}

async function handleConfigWorker(request: Request, env: typeof worker.Env) {
  const configWorker = env.LOADER.get(
    "config-reloader",
    async () => {
      return {
        compatibilityDate: "2025-06-01",
        mainModule: "config.js",
        modules: {
          "config.js": `
            export default {
              async fetch(request) {
                const config = {
                  version: "1.0.0",
                  lastUpdated: new Date().toISOString(),
                  features: {
                    dynamicWorkers: true,
                    metricsCollection: true,
                    configReload: true,
                    gracefulShutdown: true,
                  },
                  settings: {
                    updateInterval: "30s",
                    healthCheckInterval: "10s",
                    maxRetries: 3,
                  }
                };
                
                return new Response(JSON.stringify(config, null, 2), {
                  headers: { 'Content-Type': 'application/json' }
                });
              }
            }
          `,
        },
      };
    },
  );

  const entrypoint = configWorker.getEntrypoint();
  return entrypoint.fetch(new URL(request.url));
}

async function handleHome(request: Request, env: typeof worker.Env) {
  const html = `
<!DOCTYPE html>
<html>
<head>
    <title>Dynamic Worker Loader Demo</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .endpoint { background: #f5f5f5; padding: 15px; margin: 10px 0; border-radius: 5px; }
        .endpoint h3 { margin: 0 0 10px 0; color: #333; }
        .endpoint p { margin: 0; color: #666; }
        .endpoint code { background: #e8e8e8; padding: 2px 5px; border-radius: 3px; }
        a { color: #0066cc; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <h1>üöÄ Dynamic Worker Loader Demo</h1>
    <p>This demo showcases the WorkerLoader binding type in Alchemy, enabling dynamic worker creation at runtime.</p>
    
    <div class="endpoint">
        <h3>üîÑ Dynamic Worker</h3>
        <p>Creates a new dynamic worker on each request</p>
        <p><code>GET /dynamic</code> - <a href="/dynamic">Try it</a></p>
    </div>
    
    <div class="endpoint">
        <h3>üìä Metrics Worker</h3>
        <p>Dedicated metrics collection worker</p>
        <p><code>GET /metrics</code> - <a href="/metrics">Try it</a></p>
    </div>
    
    <div class="endpoint">
        <h3>‚öôÔ∏è Config Worker</h3>
        <p>Configuration management worker</p>
        <p><code>GET /config</code> - <a href="/config">Try it</a></p>
    </div>
    
    <h2>üéØ Features Demonstrated</h2>
    <ul>
        <li><strong>Dynamic Worker Creation</strong>: Workers created at runtime</li>
        <li><strong>Worker Caching</strong>: Workers cached by key for performance</li>
        <li><strong>Modular Architecture</strong>: Separate workers for different concerns</li>
        <li><strong>Hot Reloading</strong>: Workers can be updated without restart</li>
        <li><strong>Resource Efficiency</strong>: Workers created only when needed</li>
    </ul>
    
    <h2>üîß Technical Details</h2>
    <p>This demo uses the <code>WorkerLoader</code> binding type to create workers dynamically:</p>
    <pre><code>const dynamicWorker = env.LOADER.get(
  'worker-key',
  async () => ({
    compatibilityDate: "2025-06-01",
    mainModule: "index.js",
    modules: {
      'index.js': '/* worker code */'
    },
  })
);</code></pre>
</body>
</html>
  `;

  return new Response(html, {
    headers: { "Content-Type": "text/html" },
  });
}
